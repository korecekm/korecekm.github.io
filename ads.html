<!DOCTYPE html>
<meta charset="UTF-8">

<html>

<head>
    <title>Algoritmy a datové struktury 1 - Cvičení</title>
    <link rel="stylesheet" type="text/css" href="main.css">
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
        });
    </script>
    <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>

<body>

<div id="content">
    <h1>Algoritmy a datové struktury 1 &ndash; cvičení</h1>
    <span class="addinfo">Cvičí Martin Koreček k <a href="https://mj.ucw.cz/vyuka/2223/ads1/">přednášce Martina Mareše</a>.</span>
    <br>
    <span class="addinfo">Letní semestr 2022/23, středa 14:00, učebna N3.</span>


    <h2>Podmínky pro získání zápočtu</h2>
    <p>
        Na každém cviku zpravidla zadám jeden domácí úkol. Čas na vypracování bude 14 dní. Občas můžu zadat bonusový úkol.
    </p>
    <p>
        Na zápočet je třeba získat alespoň dvě třetiny počtu bodů ze standardních úloh (bonusové se počítají jen do vašeho skóre).
    </p>
    

    <h2>Co jsme dělali</h2>
    
    <p>
        <span class="highlight">15.2.:</span> Opakování \(\mathcal{O}\) notace, programování na RAMu.
        <a href="cviceni/cviko01.pdf">Úlohy (PDF)</a>
    </p>
    <p>
        <span class="highlight">22.2.:</span> Dokončení úloh z minulého týdne.
        Prohledávání grafů. <a href="cviceni/cviko02.pdf">Úlohy (PDF)</a>
    </p>
    <p>
        <span class="highlight">1.3.:</span> DFS, klasifikace hran, mosty a artikulace.
        <a href="cviceni/cviko03.pdf">Úlohy (PDF)</a>
    </p>
    <p>
        <span class="highlight">8.3.:</span> Topologická indukce, komponenty silné souvislosti, Dijkstra.
        <a href="cviceni/cviko04.pdf">Úlohy (PDF)</a>
    </p>
    <p>
        <span class="highlight">15.3.:</span> Pokračování Dijkstry, Bellman-Ford.
        <a href="cviceni/cviko05.pdf">Úlohy (PDF)</a>
    </p>
    <p class="addinfo">
        Pro zajímavost: někdejší matfyzáci vytvořili pěkná videa o technikách <a href="https://youtu.be/A60q6dcoCjw">A*</a>
        a <a href="https://youtu.be/wL3uWO-KLUE">Meet in the Middle</a>. Obě techniky jsou podrobněji popsány také v Průvodci (od 2. vydání).
    </p>
    <p class="addinfo">
        IDA* bohužel v Průvodci nenajdete, ale můžete si o něm přečíst např. na
        <a href="https://en.wikipedia.org/wiki/Iterative_deepening_A*">Wikipedii</a>.
    </p>
    <p>
        <span class="highlight">22.3.:</span> Minimální kostry.
        <a href="cviceni/cviko06.pdf">Úlohy (PDF)</a>
    </p>
    <p>
        <span class="highlight">29.3.:</span> Binární vyhledávací stromy.
        <a href="cviceni/cviko07.pdf">Úlohy (PDF)</a>
    </p>
    <p>
        <span class="highlight">5.4.:</span> Vyvažované stromy.
        <a href="cviceni/cviko08.pdf">Úlohy (PDF)</a>
    </p>
    <p>
        <span class="highlight">12.4.:</span> Intervalové dotazy, trie, hešování.
        <a href="cviceni/cviko09.pdf">Úlohy (PDF)</a>
    </p>
    <p class="addinfo">
        Fun fact: v čichovém ústrojí much bylo objeveno <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6304992/">
            něco velmi podobného Bloomovu filtru</a>, sloužící k detekci dosud neznámých zápachů.
    </p>
    <p>19.4.: <span class="addinfo">Cvičení nebylo.</span></p>
    <p>
        <span class="highlight">26.4.</span> Rozděl a panuj.
        <a href="cviceni/cviko10.pdf">Úlohy (PDF)</a>
    </p>


    <h2>Domácí úkoly</h2>
    <p class="addinfo">
        Odevzdávejte buď na papíře před začátkem cvičení, nebo v TXT/PDF na e-mail <a href="mailto:mk-hw@seznam.cz">mk-hw@seznam.cz</a>.
    </p>
    <p class="addinfo">
        Cílem úkolů není, abyste napsali program v nějakém programovacím jazyce (s výjimkou první úlohy), proto neodevzdávejte zdrojové kódy.
        Jak řešení má vypadat dost dobře vystihihují <a href="https://ksp.mff.cuni.cz/h/pravidla/#teoreticke-ulohy">pravidla řešení teoretických úloh</a> Korespondenčního semináře z programování.
    </p>
    <ul>
    <li>
    <span class="highlight">DÚ 1: </span>Naprogramujte na RAMu libovolný třídící algoritmus pracující
    v čase \(\mathcal{O}(n \log n)\): V buňkách <code>[1]</code> až <code>[n]</code> bude posloupnost
    celých čísel a po zastavení programu chceme, aby byla setříděná. <b>(10 bodů) Deadline: 1.3.</b>
    <br>
    <span class="addinfo">
        Budete-li odevzdávat e-mailem, nejvhodnější asi bude jednoduchý texťák.
        <br>
        Quicksort, co bere za pivot vždy první buňku taky uznám (řekněme, že posloupnost
        je na začátku náhodně zpermutovaná).
        <br>
        Může se hodit <a href="https://iuuk.mff.cuni.cz/~husek/ram-sim/ram_simulator.html">simulátor RAMu</a>
        od Radka Huška. Jeho syntaxe se neshoduje s tou z přednášky, ale budu ji uznávat.
    </span></li>
    <li><span class="highlight">Bonusový úkol 1: </span>Uvažme RAM s neomezenou kapacitou buněk a s počítáním
        aritmetických operací v konstantním čase. Vymyslete, jak v tomto modelu násobit čtvercové
        matice \(n\times n\) v čase \(\mathcal{O}(n^2)\). <b>(10 bodů) Deadline: 1.3.</b></li>
    <li><span class="highlight">DÚ 2: </span>Řekneme, že (neorientovaný) graf je \(d\)-degenerovaný,
        pokud existuje pořadí odtrhávání vrcholů takové, že každý odtrhávaný vrchol má aktuální stupeň
        maximálně \(d\). Pro zadaný graf \(G\) najděte nejmenší \(d\) takové, že \(G\)
        je \(d\)-degenerovaný <span class="addinfo">(jde to v lineárním čase, za pomalejší řešení
        dostanete část bodů)</span>. <b>(10 bodů) Deadline: 8.3.</b>
    </li>
    <li><span class="highlight">DÚ 3: </span>Mějme zadána dvě bludiště, tj. čtverečkové sítě tvaru \(r\times s\),
        kde některé čtverečky představují „zdi“. V každém bludišti se na některém políčku nachází robot a oba roboti
        reagují na ovladač, kterým můžeme dávat povely pro posun o políčko nahoru, dolů, doleva a doprava.
        Na každý povel reagují oba roboti. Pokud má robot v udaném směru zeď, zůstane na místě (ale nezastaví tím druhého robota).
        Ve chvíli, kdy se robot dostane ven z bludiště (pohybem mimo krajní políčko), zastaví se a pozdější povely ignoruje.
        Vymyslete algoritmus, který najde <i>nejkratší</i> posloupnost povelů, která dostane oba roboty ven z bludiště.
        Časovou a paměťovou složitost vztahujte k rozměrům bludišť (tj. \(r\) a \(s\)). <b>(10 bodů) Deadline: 15.3.</b>
    </li>
    <li><span class="highlight">DÚ 4: </span>Jak najít <i>nejdelší</i> cestu v orientovaném acyklickém grafu,
        když je dáno <i>ohodnocení</i> hran udávající jejich délku? <b>(10 bodů) Deadline: 22.3.</b>
    </li>
    <li><span class="highlight">DÚ 5: </span>Silnice v mapě máme ohodnocené dvěma nezápornými čísly: délkou a mýtem
        (poplatkem za projetí). Jak najít nejlevnější z nejkratších cest mezi dvěma zadanými místy? <b>(10 bodů) Deadline: 29.3.</b>
    </li>
    <li><span class="highlight">DÚ 6: </span>Posíláme po síti velké množství obrázků a chceme, aby to netrvalo dlouho.
        Každý obrázek má \(B\) bytů a můžeme ho buď poslat samostatně nezávisle na ostatních, nebo jako zakódovaný rozdíl oproti
        jinému, již přenesenému snímku.
        Rozdíly mezi snímky už máme předpočítané, takže pro \(i\)-tý a \(j\)-tý obrázek můžeme v konstantním čase najít
        \(D_{ij}\), velikost rozdílu mezi nimi v bytech.
        <br>
        Navrhněte algoritmus, který najde pořadí a způsob (celý obrázek vs. diff s již odeslaným obrázkem) odesílání obrázků,
        abychom celkem odeslali co nejméně bytů dat. O hodnotách \(D_{ij}\) víme jen, že \(D_{ij} = D_{ji}~\forall i, j\).
        Hodnoty \(D_{ij}\) a \(D_{jk}\) nic neříkají o \(D_{ik}\).
        <b>(10 bodů) Deadline: 5.4.</b> 
    </li>
    <li><span class="highlight">DÚ 7: </span>Upravte BVS strom tak, aby dokázal odpovídat na dotaz, <i>kolik</i> uložených
        klíčů má hodnotu v zadaném rozsahu \([a, b]\). Chceme, aby všechny operace (včetně této) měly složitost
        \(\mathcal{O}(h)\), kde \(h\) je hloubka stromu.
        <b>(10 bodů) Deadline: 12.4.</b> 
    </li>
    <li><span class="highlight">DÚ 8: </span>Použijte vyhledávací stromy k návrhu datové struktury, která postupně
        dostává celá čísla a po každém novém číslu vrátí medián z posledních \(k\) hodnot. Tato operace, tj. vložení nového čísla
        a vrácení aktuálního mediánu, by měla trvat \(\mathcal{O}(\log k)\).
        Konstanta \(k\) je <i>zadána před inicializací</i> struktury.
        <b>(10 bodů) Deadline: 19.4.</b>
    </li>
    <li><span class="highlight">DÚ 9: </span>Viděli jsme, jak hešovací tabulku postupně zvětšovat tak, že \(n\) operací
        stojí čas \(\mathcal{O}(n)\). Co když chceme taky zaručit, že když zrovna máme uložených \(k\) prvků, tabulka zabere jen \(\mathcal{O}(k)\) paměti?
        Navrhněte, jak toto zaručit postupným zmenšováním tabulky když počet prvků klesne pod nějakou úroveň.
        Posloupnost \(x\) <i>insert</i>ů a \(y\) <i>delet</i>ů v libovolném pořadí by měla zabrat čas \(\mathcal{O}(x+y)\).
        <b>(10 bodů) Deadline: 26.4.</b>
    </li>
    <li><span class="highlight">DÚ 10: </span>Zlepší se časová efektivita binárního vyhledávání, pokud
        interval nebudeme půlit, ale dělit na třetiny? Snadno se rozmyslí, že asymptotická složitost zůstane \(\Theta(\log n)\),
        ale jak je to s konstantami? Spočtěte, jak efektivní takové "ternární″ vyhledávání je oproti binárnímu.
        <b>(10 bodů) Deadline: 10.5.</b>
    </li>
    <li><span class="highlight">Bonusový úkol 2: </span>Aerolinka "<i>Eastward</i>″ léta pouze na východ.
        Města, mezi kterými létá, se dají jednoznačně seřadit od nejzápadnějšího po nejvýchodnější na \(m_1,\ldots,m_n\).
        Chceme, aby bylo možné z každého města \(m_i\) doletět do libovolného východnějšího města \(m_j\) \((i < j)\).
        Aby to šlo bez přestupu, potřebovali by <i>Eastward</i> provozovat \(\Omega(n^2)\) spojů.
        Můžeme taky mít spoje jen mezi městy \(m_i\) a \(m_{i+1}\), pak ale někteří pasážéři budou muset přestupovat \(\Omega(n)\)-krát,
        než se dostanou do cíle.
        <br>
        Navrhněte proto \(\mathcal{O}(n \log n)\) spojů mířících pouze na východ, které zajistí, že žádný cestující nebude
        muset přestoupit víc než jednou. <i>Eastward</i> operuje na placaté Zeměploše, takže z města \(m_n\) se nedá dostat do
        města \(m_1\) letem na východ.
        <b>(10 bodů) Deadline: 10.5.</b>
    </li>
    </ul>

    <p>
        Průběžné výsledky: <a href="ads/vysledky">Tabulka bodů</a>
    </p>

    <h2>Užitečné odkazy</h2>
    <p>
        <a href="https://mj.ucw.cz/vyuka/2223/ads1/">Stránka přednášky.</a>
    </p>
    <p>
        Knížka <a href="http://pruvodce.ucw.cz/">Průvodce labyrintem algoritmů</a>, která pokrývá (nejen) celý sylabus předmětu.
    </p>
    <p>
        Archiv úloh <a href="https://ksp.mff.cuni.cz/h/ulohy/">Korespondenčního semináře z programování.</a>
    </p>
    <p>
        Soutěžní programování: <a href="https://codeforces.com/">Codeforces</a>, <a href="https://www.spoj.com/">Spoj</a>,
        <a href="https://www.hackerrank.com/dashboard">HackerRank</a>, <a href="https://www.codechef.com/">CodeChef</a>.
    </p>
    <p>
        Zábavné kódící úlohy: <a href="https://projecteuler.net/">Project Euler</a>.
    </p>
</div>

</body>
